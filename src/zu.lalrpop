use crate::pass::parser::Parsed;
use crate::ast::Element;
use std::str::FromStr;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, crate::pass::parser::InnerError>>, filename: &str);

extern {
  type Error = crate::pass::parser::InnerError;
}

/// Parses an entire file declaration into the abstract Parsed tree, so
/// we can resolve and typecheck it.
pub File: crate::ast::File<Parsed> = {
  <s: @L> <name:ModuleName?> <stmts:Stmt*> <e: @R> => crate::ast::File {
    // Remove the .zu extension from filenames, so the modules are more
    // idiomatic.
    name: name.unwrap_or_else(|| filename.to_string().replace(".zu", "")),
    stmts,
    meta: crate::ast::Location::new(s, e, filename),
  },
}

/// Parses the header module declaration within the file, this is used to
/// declare the module name.
pub ModuleName: String = {
  "module" <name:Reference> "." => name.text,
}

/// Parses a value, this is a term that can be used as a value.
pub Value: crate::ast::Term<Parsed> = {
  <s: @L> ":=" <value:Term> <e: @R> => value.into(),
}

/// Parses a top-level statement, this is a statement that can be used
/// outside of a block.
pub Stmt: crate::ast::Stmt<Parsed> = {
  // SECTION: Commands
  // 
  // Parses `@eval` command, which evaluates a term and prints the result.
  <s: @L> "@eval" <value:Term> "." <e: @R> => crate::ast::Stmt::Eval(crate::ast::Eval {
    value,
    meta: crate::ast::Location::new(s, e, filename),
  }),

  // Parses `@type` command, which types a term and prints the result.
  <s: @L> "@type" <value:Term> "." <e: @R> => crate::ast::Stmt::Type(crate::ast::Type {
    value,
    meta: crate::ast::Location::new(s, e, filename),
  }),

  // Parses `@import` command, which set to the resolver to import to the
  // current file.
  <s: @L> "import" <import:Reference> "." <e: @R> => crate::ast::Stmt::Import(crate::pass::parser::Import {
    text: import.text,
    meta: crate::ast::Location::new(s, e, filename),
  }),

  // Parses a simple signature binding, which haves a type, value and a name.
  //
  // It can be compared to a function signature, or let binding in other languages.
  <s: @L> <doc_strings:DocString*> <name:Reference> <type_repr:TypeRepr?> <value:Value?> "." <e: @R> => match (type_repr, value) {
    // Unacceptable Binding
    (None, None) => {
      // Report the error
      errors.push(lalrpop_util::ErrorRecovery {
          dropped_tokens: vec![],
          error: lalrpop_util::ParseError::User {
              error: crate::pass::parser::InnerError::ExpectedStatement {
                  err_span: miette::SourceSpan::from(s..e),
              }
          },
      });

      // Return the default sentinel value for statements, which is an error.
      crate::ast::Stmt::Error(crate::ast::Error {
        message: format!("expected a type or value for binding `{}`", name.text),
        full_text: (&input[s..e]).to_string(),
        meta: crate::ast::Location::new(s, e, filename),
      })
    }
    // Infer Binding
    (None, Some(value)) => {
      crate::ast::Stmt::Binding(crate::ast::Binding {
        doc_strings,
        attributes: vec![],
        type_repr: crate::ast::Term::Hole(crate::ast::Hole {
          meta: crate::ast::Location::clone(<crate::pass::parser::Reference as crate::ast::Element<Parsed>>::meta(&name)),
        }),
        name,
        value: value.into(),
        meta: crate::ast::Location::new(s, e, filename),
      })
    }
    // Signature
    (Some(type_repr), None) => {
      crate::ast::Stmt::Signature(crate::pass::parser::Signature {
        type_repr: type_repr.into(),
        name,
        meta: crate::ast::Location::new(s, e, filename),
      })
    }
    // Typed Binding
    (Some(type_repr), Some(value)) => {
      crate::ast::Stmt::Binding(crate::ast::Binding {
        doc_strings,
        attributes: vec![],
        type_repr: type_repr.into(),
        name,
        value: value.into(),
        meta: crate::ast::Location::new(s, e, filename),
      })
    }
  },
}

/// Parses an optional type representation for a statement, this is a colon
/// followed by a type representation.
pub TypeRepr: crate::ast::Term<Parsed> = {
  ":" <value:Term> => value.into(),
}

/// Primary expressions, that aren't necessary expressions but can be used as
/// the base of an expression.
pub Primary: crate::ast::Term<Parsed> = {
  "(" <Term> ")" => crate::ast::Term::Group(<>.into()),
  <r:Reference> => match r.text {
    _ if r.text == "_" => crate::ast::Term::Hole(crate::ast::Hole { meta: r.meta.clone() }),
    _ if r.text == "Type" => crate::ast::Term::Universe(crate::ast::Universe { meta: r.meta.clone() }),
    _ => crate::ast::Term::Reference(r),
  },
  <s: @L> <value:String> <e: @R> => crate::ast::Term::Str(crate::ast::Str {
    value,
    meta: crate::ast::Location::new(s, e, filename),
  }),
  <s: @L> <value:Int> <e: @R> => crate::ast::Term::Int(crate::ast::Int {
    value,
    meta: crate::ast::Location::new(s, e, filename),
  }),

  // Error handling for the parser, this is used to report errors when the
  // parser fails to parse a term.
  <s: @L> <error:!> <e: @R> => {
    errors.push(error);

    crate::ast::Term::Error(crate::ast::Error {
      message: "failed to parse term".to_string(),
      full_text: (&input[s..e]).to_string(),
      meta: crate::ast::Location::new(s, e, filename),
    })
  },
}

/// Parses a call with a single argument, this is a primary term followed by a
/// single argument.
pub Apply: crate::ast::Term<Parsed> = {
  <s: @L> <callee:Call> <argument:Primary> <e: @R> => match callee.clone().unwrap() {
    crate::ast::Term::Apply(mut apply) => {
      apply.arguments.push(argument);
      crate::ast::Term::Apply(apply)
    }
    _ => crate::ast::Term::Apply(crate::ast::Apply {
      callee: Box::new(callee),
      arguments: vec![argument],
      meta: crate::ast::Location::new(s, e, filename),
    }),
  },
}

/// Parses a pi expression, this is a list of arguments followed by an arrow
/// and a value.
pub Pi: crate::ast::Pi<Parsed> = {
  <s: @L> <domain:Domain> "->" <value:Arrow> <e: @R> => crate::ast::Pi {
    meta: crate::ast::Location::new(s, e, filename),
    icit: crate::ast::Icit::Expl,
    codomain: value.into(),
    domain,
  },
}

/// Arrow type signature, this is a domain followed by an arrow and a value.
pub Arrow: crate::ast::Term<Parsed> = {
  Call,
  <Pi> => crate::ast::Term::Pi(<>),
}

/// Parses a lambda function, this is a list of arguments followed by an arrow
/// and a value.
pub Fun: crate::ast::Term<Parsed> = {
  <s: @L> "\\" <arguments:Sep<",", Reference>> "->" <value:Term> <e: @R> => crate::ast::Term::Fun(crate::ast::Fun {
    arguments,
    value: value.into(),
    meta: crate::ast::Location::new(s, e, filename),
  })
}

/// Represents a domain for pi expressions, this is a variable with a type.
pub Domain: crate::ast::Domain<Parsed> = {
  /// Parses unnamed explicit arguments, which you don't need to specify
  /// the type and neither the name.
  <term:Call> => crate::ast::Domain {
    name: vec![None],
    meta: term.meta().clone(),
    type_repr: term.into(),
    icit: crate::ast::Icit::Expl,
  },

  // Parses explicit arguments, which you need to specify
  // the type.
  <s: @L> <names:Sep<",", Reference>> ":" <value:Call> <e: @R> => crate::ast::Domain {
    name: names.into_iter().map(Some).collect(),
    type_repr: value.into(),
    icit: crate::ast::Icit::Expl,
    meta: crate::ast::Location::new(s, e, filename),
  },
  
  // Parses explicit arguments, which you don't need to specify
  // the type.
  <s: @L> "{" <names:Sep<",", Reference>> ":" <value:Term> "}" <e: @R> => crate::ast::Domain {
    name: names.into_iter().map(Some).collect(),
    type_repr: value.into(),
    icit: crate::ast::Icit::Impl,
    meta: crate::ast::Location::new(s, e, filename),
  },
}

/// Parses a call, this is a primary term followed by a list of arguments. It can 
/// parse either a call or a call with a single argument.
pub Call: crate::ast::Term<Parsed> = {
  Primary,
  Apply,
}

/// Parser for expressions in the language, these are the terms but it doesn't
/// parses as primary.
pub Term: crate::ast::Term<Parsed> = {
  Fun,
  Arrow,
}

/// Parses a relevent document string, this is a string that is used to document
/// the code.
pub DocString: crate::ast::DocString<Parsed> = <s: @L> <text:r"--.*\n"> <e: @R> => crate::ast::DocString {
  text: (&text[2..]).to_string(),
  full_text: text.to_string(),
  meta: crate::ast::Location::new(s, e, filename),
};

Int: isize = <s:r"[0123456789]+"> => isize::from_str(s).unwrap();
String: std::string::String = <text:r"'[^']*'"> => (&text[1..text.len() - 1]).to_string();

// Reference token text lexer
Text: std::string::String = {
  <text:"_"> => text.to_string(),
  <text:r"[a-zA-Z*/+-][a-zA-Z0-9_*/+-]*"> => text.to_string(),
}

// Reference token lexer
Reference: crate::pass::parser::Reference = {
  <s: @L> <text:Text> <e: @R> => crate::pass::parser::Reference {
    text: text.to_string(),
    meta: crate::ast::Location::new(s, e, filename),
  }
};

/// Separated by commas, this is used for function arguments. It's useful
/// to parse vectors, more specifically.
#[inline]
Sep<U, T>: Vec<T> = {
  <mut v:(<T> U)*> <e:T?> => match e {
    Some(e) => {
        v.push(e);
        v
    }
    None => v
  }
}
