module Prelude.

// | Defines inductive type for Leibniz equality and
// reflection.
// 
// Performs unification and by unification, it proves
// some value
inductive data Eq of {a}, x, y : a where
  Refl : Eq x x.

  // | Defines a proof that: `a = b`, implies `b = a` by
  // induction.
  Eq/symm : {a, b} -> a = b -> b = a
  | Refl => Refl.

// | Represents a type of a dependent pair.
@[alias $]
record Sigma of a : Type, b : Type -> Type where
  inf : a,
  ins : b a.

// | Record for lazy evaluation
@[derive new]
@[do_notation IO/pure IO/>>=]
IO : Type -> Type.
IO/pure : {a} -> a -> IO a.
IO/>>= : {a, b} -> IO a -> (IO a -> IO b) -> IO b.

// | Prints in the stdout
//
// ```
// main : IO () := do
//  println "hello world"
// ```
IO/println : String -> IO ().

// | Performs unsafe IO in the type level, or anywhere you are.
//
// It's unsafe and should not be used.
@[partial]
unsafePerformIO : {a} -> IO a -> a.
